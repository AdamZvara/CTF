'''
Created on Dec 14, 2011

@author: pablocelayes
'''

from Crypto.Util.number import long_to_bytes
import ContinuedFractions, Arithmetic

# Values obtained from the challenge
n =  84631274397936085468243460156525493102775290735093847853704748222861201907034671314563456553864922346777164693434282344497574425221033657612593119655294649874703709369961281296851862206012912737496685591093484747167344383463783148696587256713305550819118258045435980614705063476744671112349663814844258638661
e =  76375943398117578170462054836529672581413374479854195346204698501748070498956070506568266549310301818011705378232488515218655491333552181938169142939045195029987642016340970025765031391005203592715760417676735847164778995554008950800782436779304124566773492934903824066777759282956051110393644175066736135191
c =  76155184493418586791598585997636155069567358549327962203134145404023002017294930476093883887973691254620377103299793586938704148358443559625615315641070415507953921462861171469200792155613685308296735092112285738482172998011014997188244641717555210566827903227198100495628574955689734195143471067766527721453

def hack_RSA(e,n):
    '''
    Finds d knowing (e,n)
    applying the Wiener continued fraction attack
    '''
    _, convergents = ContinuedFractions.rational_to_contfrac(e, n)

    for (k,d) in convergents:

        #check if d is actually the key
        if k!=0 and (e*d-1)%k == 0:
            phi = (e*d-1)//k
            s = n - phi + 1
            # check if the equation x^2 - s*x + n = 0
            # has integer roots
            discr = s*s - 4*n
            if(discr>=0):
                t = Arithmetic.is_perfect_square(discr)
                if t!=-1 and (s+t)%2==0:
                    print("Hacked!")
                    return d


d = hack_RSA(e, n)
print(d)

ptext = pow(c, d, n)
print(long_to_bytes(ptext))